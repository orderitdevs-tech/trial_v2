# .zipline/pipeline.yml

name: "Node.js Build and Test with Artifacts"
description: "A pipeline that runs tests, builds a Node.js application, and saves multiple artifacts."

steps:
  - name: "A - Install Dependencies"
    image: "node:18-alpine"
    run: |
      echo "Installing npm dependencies..."
      # Create fake package files for demonstration
      echo '{ "name": "my-app", "scripts": { "test": "echo \\"Test coverage report generated\\"", "build": "echo \\"Build successful\\"" } }' > package.json
      echo '{ "lockfileVersion": 2 }' > package-lock.json
      npm ci
      echo "Dependencies installed."

  - name: "B - Run Tests and Generate Coverage"
    needs:
      - "A - Install Dependencies"
    image: "node:18-alpine"
    run: |
      echo "Running tests and generating coverage report..."
      # Simulate test run creating a coverage directory
      mkdir -p ./coverage
      echo "<h1>Test Coverage Report</h1>" > ./coverage/index.html
      npm test
    artifacts:
      name: "coverage-report"
      paths:
        - "./coverage"

  - name: "C - Build Application"
    needs:
      - "A - Install Dependencies"
    image: "node:18-alpine"
    run: |
      echo "Building the application..."
      # Simulate a build process creating a dist directory
      mkdir -p ./dist
      echo "console.log('Hello from the built app!');" > ./dist/app.js
      npm run build
    artifacts:
      name: "application-build"
      paths:
        - "./dist"

  - name: "D - Package for Deployment"
    needs:
      - "B - Run Tests and Generate Coverage"
      - "C - Build Application"
    image: "alpine:latest"
    run: |
      echo "Packaging final artifacts for deployment..."
      # In a real scenario, this step would download and use the artifacts
      # from steps B and C.
      sleep 5
      echo "Packaging complete."

